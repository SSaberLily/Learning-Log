这是对你今天在编写链表题目（AcWing 826. 单链表）过程中遇到的问题及解决方案的系统性总结。

这一天的经历非常有价值，因为你踩中了**数据结构初学者**和**从工程转向算法竞赛**时最容易犯的所有典型错误。

---

### 一、 核心逻辑错误（最致命）

这些错误直接导致程序崩溃（Segmentation Fault）或死循环。

#### 1. 插入节点时“断链”

- **问题描述**：在 `insertNode` 中，你创建了新节点 `newNode`，让它指向了后面的节点，但**忘记让前面的节点指向 `newNode`**。
- **后果**：链表断裂，新节点悬空。后续进行删除操作时，访问了空指针导致程序崩溃（表现为无输出）。
- **解决方案**：
  插入操作必须由**两步**组成（缺一不可）：
  1.  `newNode->next = currentNode->next;` (新节点牵右手)
  2.  `currentNode->next = newNode;` (前驱节点牵左手) **[你漏了这一步]**

#### 2. 遍历打印时的“死循环”

- **问题描述**：在 `while` 循环打印链表时，忘记写 `targetNode = targetNode->next;`。
- **后果**：指针永远停留在原地，程序疯狂打印同一个数，缓冲区爆满或被强制终止，导致你看不到输出。
- **解决方案**：写 `while` 循环遍历链表时，养成肌肉记忆，先把 `p = p->next` 写上。

---

### 二、 C++ 语法与模板错误

这些错误导致编译失败或语法不规范。

#### 1. 模板语法的误用

- **问题描述**：
  - 试图将 `main` 函数定义为 `template <class T>`（这是非法的）。
  - 在类外使用模板变量数组 `pt` 时，写成了 `pt[...]` 而不是 `pt<T>[...]`。
  - 函数参数硬编码为 `int`，破坏了模板的通用性。
- **解决方案**：
  - `main` 函数永远是普通函数。
  - 如果做算法题且只处理整数，**直接去掉模板**（如最后一次修改）是更简洁的选择。
  - 如果必须用模板，严格遵守 `template <class T>` 的声明和调用规则。

#### 2. 访问权限控制

- **问题描述**：在类中将 `firstNode` 设为 `protected`，却试图在类外（`solve` 函数中）直接访问。
- **解决方案**：在算法竞赛代码中，为了方便，通常将类成员全部设为 `public`，或者使用 `struct`（默认 public）。

---

### 三、 算法竞赛 vs. 工程开发思维差异

这是你今天最大的困惑来源（关于两种写法的区别）。

- **你的写法（指针 + Class + new）**：
  - **优点**：逻辑清晰，符合面向对象思想，适合面试和做项目。
  - **缺点**：`new` 操作慢，代码量大，容易写错指针，容易内存泄漏。
- **标准题解写法（数组模拟）**：
  - **优点**：速度极快，代码极短，通过下标直接索引（解决“第 k 个插入数”的问题非常自然）。
  - **缺点**：初学者难理解，不通用。
- **建议**：
  - **理解原理**：用指针写法（你今天已经做到了）。
  - **刷题/比赛**：熟练后建议转用**数组模拟法**，能避免超时和指针错误。

---

### 四、 今后写题的 Debug 建议

当你下次遇到**“没有输出”**的情况时，按照以下顺序排查：

1.  **是不是死循环了？**（检查 `while` 循环里指针有没有动）。
2.  **是不是访问空指针了？**（检查 `currentNode` 是否为 NULL，特别是在 `->next` 之前）。
3.  **链表是不是断了？**（检查插入逻辑是否只有一半，检查 `next` 指针是否正确连接）。
4.  **边界条件：** 如果链表是空的，或者删除了头节点，代码会崩吗？（加上 `if (head == NULL) return;` 这种防御性代码）。

今天你从“全是语法红线”改到了“逻辑死循环”，最后改到了“AC 通过”，进步非常明显！继续保持！
